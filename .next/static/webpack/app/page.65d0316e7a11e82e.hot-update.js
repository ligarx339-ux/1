"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/game-logic.ts":
/*!***************************!*\
  !*** ./lib/game-logic.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GAME_CONFIG: () => (/* binding */ GAME_CONFIG),\n/* harmony export */   gameLogic: () => (/* binding */ gameLogic)\n/* harmony export */ });\n// Updated game config for DRX mining system\nconst GAME_CONFIG = {\n    REFERRAL_BONUS: 200,\n    BASE_MINING_RATE: 0.001,\n    WELCOME_BONUS: 100,\n    JACKPOT_COOLDOWN: 3600000,\n    MIN_CLAIM_TIME: 1800,\n    MIN_CLAIM_INTERVAL: 300,\n    MAX_MINING_TIME: 86400,\n    DAILY_MINING_REWARD: 100,\n    CRITICAL_CHANCE: 0.02,\n    JACKPOT_CHANCE: 0.0005,\n    MAX_LEVEL: 50,\n    XP_PER_LEVEL: 100,\n    DRX_TO_UC_RATE: 1,\n    BASE_XP_REWARD: 50,\n    REFERRAL_XP_BONUS: 60,\n    MINING_SPEED_MULTIPLIER: 1.2,\n    CLAIM_TIME_REDUCTION: 60,\n    MINING_RATE_MULTIPLIER: 1.5\n};\nconst gameLogic = {\n    calculateMiningRewards (user, miningDuration) {\n        const baseRate = user.miningRate || GAME_CONFIG.BASE_MINING_RATE;\n        let earned = baseRate * miningDuration // duration in seconds\n        ;\n        let type = \"normal\";\n        // Calculate XP based on mining duration (30 minutes = 30 XP base)\n        let xp = Math.floor(miningDuration / 1800 * GAME_CONFIG.BASE_XP_REWARD) // 1800 seconds = 30 minutes\n        ;\n        // Apply boost multipliers to XP\n        const miningSpeedMultiplier = user.boosts.miningSpeedLevel || 1;\n        const miningRateMultiplier = user.boosts.miningRateLevel || 1;\n        xp = Math.floor(xp * Math.max(miningSpeedMultiplier, miningRateMultiplier) * 0.5);\n        // Bonus for 24h continuous mining\n        if (miningDuration >= GAME_CONFIG.MAX_MINING_TIME) {\n            earned += GAME_CONFIG.DAILY_MINING_REWARD;\n            xp += 100 // Bonus XP for 24h mining\n            ;\n            type = \"bonus\";\n        }\n        return {\n            earned,\n            type,\n            xp\n        };\n    },\n    calculateLevel (xp) {\n        let level = 1;\n        let remainingXP = xp;\n        let totalXPNeeded = 0;\n        while(remainingXP >= this.getXpForLevel(level)){\n            const xpForThisLevel = this.getXpForLevel(level);\n            remainingXP -= xpForThisLevel;\n            totalXPNeeded += xpForThisLevel;\n            level++;\n        }\n        return {\n            level,\n            currentXP: remainingXP,\n            xpForNext: this.getXpForLevel(level)\n        };\n    },\n    getXpForLevel (level) {\n        if (level === 1) return 100;\n        // Each level requires more XP progressively\n        return 100 + (level - 1) * 50;\n    },\n    calculateRank (totalEarned) {\n        var _ranks_;\n        const ranks = [\n            {\n                threshold: 0,\n                title: \"Rookie Miner\",\n                icon: \"ü•â\"\n            },\n            {\n                threshold: 1000,\n                title: \"Bronze Miner\",\n                icon: \"ü•â\"\n            },\n            {\n                threshold: 5000,\n                title: \"Silver Miner\",\n                icon: \"ü•à\"\n            },\n            {\n                threshold: 15000,\n                title: \"Gold Miner\",\n                icon: \"ü•á\"\n            },\n            {\n                threshold: 50000,\n                title: \"Platinum Miner\",\n                icon: \"üíé\"\n            },\n            {\n                threshold: 150000,\n                title: \"Diamond Miner\",\n                icon: \"üíé\"\n            },\n            {\n                threshold: 500000,\n                title: \"Master Miner\",\n                icon: \"üëë\"\n            },\n            {\n                threshold: 1500000,\n                title: \"Grandmaster Miner\",\n                icon: \"üëë\"\n            },\n            {\n                threshold: 5000000,\n                title: \"Legend Miner\",\n                icon: \"üèÜ\"\n            },\n            {\n                threshold: 15000000,\n                title: \"Mythical Miner\",\n                icon: \"‚≠ê\"\n            },\n            {\n                threshold: 50000000,\n                title: \"Ultimate Miner\",\n                icon: \"üåü\"\n            }\n        ];\n        let currentRank = 1;\n        let currentTitle = ranks[0].title;\n        let currentIcon = ranks[0].icon;\n        let nextRankAt = ((_ranks_ = ranks[1]) === null || _ranks_ === void 0 ? void 0 : _ranks_.threshold) || 0;\n        for(let i = 0; i < ranks.length; i++){\n            if (totalEarned >= ranks[i].threshold) {\n                var _ranks_1;\n                currentRank = i + 1;\n                currentTitle = ranks[i].title;\n                currentIcon = ranks[i].icon;\n                nextRankAt = ((_ranks_1 = ranks[i + 1]) === null || _ranks_1 === void 0 ? void 0 : _ranks_1.threshold) || ranks[i].threshold;\n            } else {\n                break;\n            }\n        }\n        return {\n            rank: currentRank,\n            title: currentTitle,\n            nextRankAt,\n            icon: currentIcon\n        };\n    },\n    getBoostCost (boostType, currentLevel) {\n        const baseCosts = {\n            miningSpeed: 100,\n            claimTime: 150,\n            miningRate: 200\n        };\n        const baseCost = baseCosts[boostType];\n        // Each level costs more than the previous, starting from level 1\n        return Math.floor(baseCost * Math.pow(1.5, Math.max(0, currentLevel - 1)));\n    },\n    getNextBoostValue (boostType, currentLevel, user) {\n        switch(boostType){\n            case \"miningSpeed\":\n                const nextSpeedMultiplier = Math.pow(GAME_CONFIG.MINING_SPEED_MULTIPLIER, currentLevel);\n                return \"\".concat(nextSpeedMultiplier.toFixed(1), \"x\");\n            case \"claimTime\":\n                const currentTime = user.minClaimTime || GAME_CONFIG.MIN_CLAIM_TIME;\n                const nextTime = Math.max(300, GAME_CONFIG.MIN_CLAIM_TIME - GAME_CONFIG.CLAIM_TIME_REDUCTION * currentLevel);\n                return this.formatTime(nextTime);\n            case \"miningRate\":\n                const nextRateMultiplier = Math.pow(GAME_CONFIG.MINING_RATE_MULTIPLIER, currentLevel);\n                const nextRate = GAME_CONFIG.BASE_MINING_RATE * nextRateMultiplier;\n                return \"\".concat(this.formatNumberPrecise(nextRate), \"/s\");\n            default:\n                return \"Unknown\";\n        }\n    },\n    formatNumber (num) {\n        const safeNum = typeof num === \"number\" && !isNaN(num) ? num : 0;\n        if (safeNum >= 1000000000) {\n            return Math.floor(safeNum / 1000000000) + \"B\";\n        } else if (safeNum >= 1000000) {\n            return Math.floor(safeNum / 1000000) + \"M\";\n        } else if (safeNum >= 1000) {\n            return Math.floor(safeNum / 1000) + \"K\";\n        }\n        return Math.floor(safeNum).toString();\n    },\n    formatNumberPrecise (num) {\n        const safeNum = typeof num === \"number\" && !isNaN(num) ? num : 0;\n        // Remove trailing zeros and unnecessary decimal places\n        if (safeNum === 0) return \"0\";\n        if (safeNum >= 1) return safeNum.toFixed(3).replace(/\\.?0+$/, \"\");\n        return safeNum.toFixed(6).replace(/\\.?0+$/, \"\");\n    },\n    formatTime (seconds) {\n        const safeSeconds = typeof seconds === \"number\" && !isNaN(seconds) ? Math.floor(seconds) : 0;\n        const hours = Math.floor(safeSeconds / 3600);\n        const minutes = Math.floor(safeSeconds % 3600 / 60);\n        const secs = safeSeconds % 60;\n        if (hours > 0) {\n            return \"\".concat(hours.toString().padStart(2, '0'), \":\").concat(minutes.toString().padStart(2, '0'), \":\").concat(secs.toString().padStart(2, '0'));\n        } else {\n            return \"\".concat(minutes.toString().padStart(2, '0'), \":\").concat(secs.toString().padStart(2, '0'));\n        }\n    },\n    canClaimMining (user) {\n        if (!user.isMining || !user.miningStartTime) return false;\n        const now = Date.now();\n        const miningDuration = Math.floor((now - user.miningStartTime) / 1000);\n        const timeSinceLastClaim = Math.floor((now - (user.lastClaimTime || 0)) / 1000);\n        return miningDuration >= (user.minClaimTime || GAME_CONFIG.MIN_CLAIM_TIME) && timeSinceLastClaim >= GAME_CONFIG.MIN_CLAIM_INTERVAL;\n    },\n    getMiningDuration (user) {\n        if (!user.isMining || !user.miningStartTime) return 0;\n        const now = Date.now();\n        return Math.floor((now - user.miningStartTime) / 1000);\n    },\n    calculatePendingRewards (user) {\n        const duration = this.getMiningDuration(user);\n        if (duration === 0) return 0;\n        // Apply mining time limits\n        const limitedDuration = Math.min(duration, GAME_CONFIG.MAX_MINING_TIME);\n        const { earned } = this.calculateMiningRewards(user, limitedDuration);\n        return earned;\n    },\n    getRemainingClaimTime (user) {\n        if (!user.isMining || !user.miningStartTime) return 0;\n        const now = Date.now();\n        const miningDuration = Math.floor((now - user.miningStartTime) / 1000);\n        const minTime = user.minClaimTime || GAME_CONFIG.MIN_CLAIM_TIME;\n        return Math.max(0, minTime - miningDuration);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bGliL2dhbWUtbG9naWMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBVc2VyIH0gZnJvbSBcIkAvdHlwZXNcIlxuXG4vLyBVcGRhdGVkIGdhbWUgY29uZmlnIGZvciBEUlggbWluaW5nIHN5c3RlbVxuZXhwb3J0IGNvbnN0IEdBTUVfQ09ORklHID0ge1xuICBSRUZFUlJBTF9CT05VUzogMjAwLCAvLyBEUlhcbiAgQkFTRV9NSU5JTkdfUkFURTogMC4wMDEsIC8vIERSWCBwZXIgc2Vjb25kXG4gIFdFTENPTUVfQk9OVVM6IDEwMCwgLy8gRFJYXG4gIEpBQ0tQT1RfQ09PTERPV046IDM2MDAwMDAsIC8vIDEgaG91clxuICBNSU5fQ0xBSU1fVElNRTogMTgwMCwgLy8gMzAgbWludXRlcyBtaW5pbXVtIG1pbmluZyB0aW1lXG4gIE1JTl9DTEFJTV9JTlRFUlZBTDogMzAwLCAvLyA1IG1pbnV0ZXMgbWluaW11bSBiZXR3ZWVuIGNsYWltc1xuICBNQVhfTUlOSU5HX1RJTUU6IDg2NDAwLCAvLyAyNCBob3VycyBtYXhpbXVtIG1pbmluZyB0aW1lXG4gIERBSUxZX01JTklOR19SRVdBUkQ6IDEwMCwgLy8gRFJYIGZvciAzMG1pbiBjb250aW51b3VzIG1pbmluZ1xuICBDUklUSUNBTF9DSEFOQ0U6IDAuMDIsXG4gIEpBQ0tQT1RfQ0hBTkNFOiAwLjAwMDUsXG4gIE1BWF9MRVZFTDogNTAsXG4gIFhQX1BFUl9MRVZFTDogMTAwLFxuICBEUlhfVE9fVUNfUkFURTogMSwgLy8gMSBEUlggPSAxIFVDIChjYW4gYmUgY2hhbmdlZClcbiAgQkFTRV9YUF9SRVdBUkQ6IDUwLCAvLyBCYXNlIFhQIGZvciAzMCBtaW51dGVzIG9mIG1pbmluZ1xuICBSRUZFUlJBTF9YUF9CT05VUzogNjAsIC8vIFhQIGJvbnVzIGZvciByZWZlcnJhbHNcbiAgTUlOSU5HX1NQRUVEX01VTFRJUExJRVI6IDEuMiwgLy8gQWRkZWQ6IE11bHRpcGxpZXIgZm9yIG1pbmluZyBzcGVlZCBib29zdFxuICBDTEFJTV9USU1FX1JFRFVDVElPTjogNjAsIC8vIEFkZGVkOiBSZWR1Y3Rpb24gaW4gY2xhaW0gdGltZSBwZXIgbGV2ZWwgKHNlY29uZHMpXG4gIE1JTklOR19SQVRFX01VTFRJUExJRVI6IDEuNSwgLy8gQWRkZWQ6IE11bHRpcGxpZXIgZm9yIG1pbmluZyByYXRlIGJvb3N0XG59XG5cbmV4cG9ydCBjb25zdCBnYW1lTG9naWMgPSB7XG4gIGNhbGN1bGF0ZU1pbmluZ1Jld2FyZHModXNlcjogVXNlciwgbWluaW5nRHVyYXRpb246IG51bWJlcik6IHsgZWFybmVkOiBudW1iZXI7IHR5cGU6IFwibm9ybWFsXCIgfCBcImJvbnVzXCI7IHhwOiBudW1iZXIgfSB7XG4gICAgY29uc3QgYmFzZVJhdGUgPSB1c2VyLm1pbmluZ1JhdGUgfHwgR0FNRV9DT05GSUcuQkFTRV9NSU5JTkdfUkFURVxuICAgIGxldCBlYXJuZWQgPSBiYXNlUmF0ZSAqIG1pbmluZ0R1cmF0aW9uIC8vIGR1cmF0aW9uIGluIHNlY29uZHNcbiAgICBsZXQgdHlwZTogXCJub3JtYWxcIiB8IFwiYm9udXNcIiA9IFwibm9ybWFsXCJcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgWFAgYmFzZWQgb24gbWluaW5nIGR1cmF0aW9uICgzMCBtaW51dGVzID0gMzAgWFAgYmFzZSlcbiAgICBsZXQgeHAgPSBNYXRoLmZsb29yKChtaW5pbmdEdXJhdGlvbiAvIDE4MDApICogR0FNRV9DT05GSUcuQkFTRV9YUF9SRVdBUkQpIC8vIDE4MDAgc2Vjb25kcyA9IDMwIG1pbnV0ZXNcbiAgICBcbiAgICAvLyBBcHBseSBib29zdCBtdWx0aXBsaWVycyB0byBYUFxuICAgIGNvbnN0IG1pbmluZ1NwZWVkTXVsdGlwbGllciA9IHVzZXIuYm9vc3RzLm1pbmluZ1NwZWVkTGV2ZWwgfHwgMVxuICAgIGNvbnN0IG1pbmluZ1JhdGVNdWx0aXBsaWVyID0gdXNlci5ib29zdHMubWluaW5nUmF0ZUxldmVsIHx8IDFcbiAgICB4cCA9IE1hdGguZmxvb3IoeHAgKiBNYXRoLm1heChtaW5pbmdTcGVlZE11bHRpcGxpZXIsIG1pbmluZ1JhdGVNdWx0aXBsaWVyKSAqIDAuNSlcblxuICAgIC8vIEJvbnVzIGZvciAyNGggY29udGludW91cyBtaW5pbmdcbiAgICBpZiAobWluaW5nRHVyYXRpb24gPj0gR0FNRV9DT05GSUcuTUFYX01JTklOR19USU1FKSB7XG4gICAgICBlYXJuZWQgKz0gR0FNRV9DT05GSUcuREFJTFlfTUlOSU5HX1JFV0FSRFxuICAgICAgeHAgKz0gMTAwIC8vIEJvbnVzIFhQIGZvciAyNGggbWluaW5nXG4gICAgICB0eXBlID0gXCJib251c1wiXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZWFybmVkLCB0eXBlLCB4cCB9XG4gIH0sXG5cbiAgY2FsY3VsYXRlTGV2ZWwoeHA6IG51bWJlcik6IHsgbGV2ZWw6IG51bWJlcjsgY3VycmVudFhQOiBudW1iZXI7IHhwRm9yTmV4dDogbnVtYmVyIH0ge1xuICAgIGxldCBsZXZlbCA9IDFcbiAgICBsZXQgcmVtYWluaW5nWFAgPSB4cFxuICAgIGxldCB0b3RhbFhQTmVlZGVkID0gMFxuXG4gICAgd2hpbGUgKHJlbWFpbmluZ1hQID49IHRoaXMuZ2V0WHBGb3JMZXZlbChsZXZlbCkpIHtcbiAgICAgIGNvbnN0IHhwRm9yVGhpc0xldmVsID0gdGhpcy5nZXRYcEZvckxldmVsKGxldmVsKVxuICAgICAgcmVtYWluaW5nWFAgLT0geHBGb3JUaGlzTGV2ZWxcbiAgICAgIHRvdGFsWFBOZWVkZWQgKz0geHBGb3JUaGlzTGV2ZWxcbiAgICAgIGxldmVsKytcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWwsXG4gICAgICBjdXJyZW50WFA6IHJlbWFpbmluZ1hQLFxuICAgICAgeHBGb3JOZXh0OiB0aGlzLmdldFhwRm9yTGV2ZWwobGV2ZWwpLFxuICAgIH1cbiAgfSxcblxuICBnZXRYcEZvckxldmVsKGxldmVsOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChsZXZlbCA9PT0gMSkgcmV0dXJuIDEwMFxuICAgIC8vIEVhY2ggbGV2ZWwgcmVxdWlyZXMgbW9yZSBYUCBwcm9ncmVzc2l2ZWx5XG4gICAgcmV0dXJuIDEwMCArIChsZXZlbCAtIDEpICogNTBcbiAgfSxcblxuICBjYWxjdWxhdGVSYW5rKHRvdGFsRWFybmVkOiBudW1iZXIpOiB7IHJhbms6IG51bWJlcjsgdGl0bGU6IHN0cmluZzsgbmV4dFJhbmtBdDogbnVtYmVyOyBpY29uOiBzdHJpbmcgfSB7XG4gICAgY29uc3QgcmFua3MgPSBbXG4gICAgICB7IHRocmVzaG9sZDogMCwgdGl0bGU6IFwiUm9va2llIE1pbmVyXCIsIGljb246IFwi8J+liVwiIH0sXG4gICAgICB7IHRocmVzaG9sZDogMTAwMCwgdGl0bGU6IFwiQnJvbnplIE1pbmVyXCIsIGljb246IFwi8J+liVwiIH0sXG4gICAgICB7IHRocmVzaG9sZDogNTAwMCwgdGl0bGU6IFwiU2lsdmVyIE1pbmVyXCIsIGljb246IFwi8J+liFwiIH0sXG4gICAgICB7IHRocmVzaG9sZDogMTUwMDAsIHRpdGxlOiBcIkdvbGQgTWluZXJcIiwgaWNvbjogXCLwn6WHXCIgfSxcbiAgICAgIHsgdGhyZXNob2xkOiA1MDAwMCwgdGl0bGU6IFwiUGxhdGludW0gTWluZXJcIiwgaWNvbjogXCLwn5KOXCIgfSxcbiAgICAgIHsgdGhyZXNob2xkOiAxNTAwMDAsIHRpdGxlOiBcIkRpYW1vbmQgTWluZXJcIiwgaWNvbjogXCLwn5KOXCIgfSxcbiAgICAgIHsgdGhyZXNob2xkOiA1MDAwMDAsIHRpdGxlOiBcIk1hc3RlciBNaW5lclwiLCBpY29uOiBcIvCfkZFcIiB9LFxuICAgICAgeyB0aHJlc2hvbGQ6IDE1MDAwMDAsIHRpdGxlOiBcIkdyYW5kbWFzdGVyIE1pbmVyXCIsIGljb246IFwi8J+RkVwiIH0sXG4gICAgICB7IHRocmVzaG9sZDogNTAwMDAwMCwgdGl0bGU6IFwiTGVnZW5kIE1pbmVyXCIsIGljb246IFwi8J+PhlwiIH0sXG4gICAgICB7IHRocmVzaG9sZDogMTUwMDAwMDAsIHRpdGxlOiBcIk15dGhpY2FsIE1pbmVyXCIsIGljb246IFwi4q2QXCIgfSxcbiAgICAgIHsgdGhyZXNob2xkOiA1MDAwMDAwMCwgdGl0bGU6IFwiVWx0aW1hdGUgTWluZXJcIiwgaWNvbjogXCLwn4yfXCIgfSxcbiAgICBdXG5cbiAgICBsZXQgY3VycmVudFJhbmsgPSAxXG4gICAgbGV0IGN1cnJlbnRUaXRsZSA9IHJhbmtzWzBdLnRpdGxlXG4gICAgbGV0IGN1cnJlbnRJY29uID0gcmFua3NbMF0uaWNvblxuICAgIGxldCBuZXh0UmFua0F0ID0gcmFua3NbMV0/LnRocmVzaG9sZCB8fCAwXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodG90YWxFYXJuZWQgPj0gcmFua3NbaV0udGhyZXNob2xkKSB7XG4gICAgICAgIGN1cnJlbnRSYW5rID0gaSArIDFcbiAgICAgICAgY3VycmVudFRpdGxlID0gcmFua3NbaV0udGl0bGVcbiAgICAgICAgY3VycmVudEljb24gPSByYW5rc1tpXS5pY29uXG4gICAgICAgIG5leHRSYW5rQXQgPSByYW5rc1tpICsgMV0/LnRocmVzaG9sZCB8fCByYW5rc1tpXS50aHJlc2hvbGRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJhbms6IGN1cnJlbnRSYW5rLFxuICAgICAgdGl0bGU6IGN1cnJlbnRUaXRsZSxcbiAgICAgIG5leHRSYW5rQXQsXG4gICAgICBpY29uOiBjdXJyZW50SWNvbixcbiAgICB9XG4gIH0sXG5cbiAgZ2V0Qm9vc3RDb3N0KGJvb3N0VHlwZTogXCJtaW5pbmdTcGVlZFwiIHwgXCJjbGFpbVRpbWVcIiB8IFwibWluaW5nUmF0ZVwiLCBjdXJyZW50TGV2ZWw6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgYmFzZUNvc3RzID0ge1xuICAgICAgbWluaW5nU3BlZWQ6IDEwMCxcbiAgICAgIGNsYWltVGltZTogMTUwLFxuICAgICAgbWluaW5nUmF0ZTogMjAwLFxuICAgIH1cblxuICAgIGNvbnN0IGJhc2VDb3N0ID0gYmFzZUNvc3RzW2Jvb3N0VHlwZV1cbiAgICAvLyBFYWNoIGxldmVsIGNvc3RzIG1vcmUgdGhhbiB0aGUgcHJldmlvdXMsIHN0YXJ0aW5nIGZyb20gbGV2ZWwgMVxuICAgIHJldHVybiBNYXRoLmZsb29yKGJhc2VDb3N0ICogTWF0aC5wb3coMS41LCBNYXRoLm1heCgwLCBjdXJyZW50TGV2ZWwgLSAxKSkpXG4gIH0sXG5cbiAgZ2V0TmV4dEJvb3N0VmFsdWUoYm9vc3RUeXBlOiBcIm1pbmluZ1NwZWVkXCIgfCBcImNsYWltVGltZVwiIHwgXCJtaW5pbmdSYXRlXCIsIGN1cnJlbnRMZXZlbDogbnVtYmVyLCB1c2VyOiBVc2VyKTogc3RyaW5nIHtcbiAgICBzd2l0Y2ggKGJvb3N0VHlwZSkge1xuICAgICAgY2FzZSBcIm1pbmluZ1NwZWVkXCI6XG4gICAgICAgIGNvbnN0IG5leHRTcGVlZE11bHRpcGxpZXIgPSBNYXRoLnBvdyhHQU1FX0NPTkZJRy5NSU5JTkdfU1BFRURfTVVMVElQTElFUiwgY3VycmVudExldmVsKVxuICAgICAgICByZXR1cm4gYCR7bmV4dFNwZWVkTXVsdGlwbGllci50b0ZpeGVkKDEpfXhgXG4gICAgICBjYXNlIFwiY2xhaW1UaW1lXCI6XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdXNlci5taW5DbGFpbVRpbWUgfHwgR0FNRV9DT05GSUcuTUlOX0NMQUlNX1RJTUVcbiAgICAgICAgY29uc3QgbmV4dFRpbWUgPSBNYXRoLm1heCgzMDAsIEdBTUVfQ09ORklHLk1JTl9DTEFJTV9USU1FIC0gKEdBTUVfQ09ORklHLkNMQUlNX1RJTUVfUkVEVUNUSU9OICogY3VycmVudExldmVsKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0VGltZShuZXh0VGltZSlcbiAgICAgIGNhc2UgXCJtaW5pbmdSYXRlXCI6XG4gICAgICAgIGNvbnN0IG5leHRSYXRlTXVsdGlwbGllciA9IE1hdGgucG93KEdBTUVfQ09ORklHLk1JTklOR19SQVRFX01VTFRJUExJRVIsIGN1cnJlbnRMZXZlbClcbiAgICAgICAgY29uc3QgbmV4dFJhdGUgPSBHQU1FX0NPTkZJRy5CQVNFX01JTklOR19SQVRFICogbmV4dFJhdGVNdWx0aXBsaWVyXG4gICAgICAgIHJldHVybiBgJHt0aGlzLmZvcm1hdE51bWJlclByZWNpc2UobmV4dFJhdGUpfS9zYFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFwiVW5rbm93blwiXG4gICAgfVxuICB9LFxuXG4gIGZvcm1hdE51bWJlcihudW06IG51bWJlciB8IHVuZGVmaW5lZCB8IG51bGwpOiBzdHJpbmcge1xuICAgIGNvbnN0IHNhZmVOdW0gPSB0eXBlb2YgbnVtID09PSBcIm51bWJlclwiICYmICFpc05hTihudW0pID8gbnVtIDogMFxuXG4gICAgaWYgKHNhZmVOdW0gPj0gMTAwMDAwMDAwMCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3Ioc2FmZU51bSAvIDEwMDAwMDAwMDApICsgXCJCXCJcbiAgICB9IGVsc2UgaWYgKHNhZmVOdW0gPj0gMTAwMDAwMCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3Ioc2FmZU51bSAvIDEwMDAwMDApICsgXCJNXCJcbiAgICB9IGVsc2UgaWYgKHNhZmVOdW0gPj0gMTAwMCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3Ioc2FmZU51bSAvIDEwMDApICsgXCJLXCJcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguZmxvb3Ioc2FmZU51bSkudG9TdHJpbmcoKVxuICB9LFxuXG4gIGZvcm1hdE51bWJlclByZWNpc2UobnVtOiBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsKTogc3RyaW5nIHtcbiAgICBjb25zdCBzYWZlTnVtID0gdHlwZW9mIG51bSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4obnVtKSA/IG51bSA6IDBcbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MgYW5kIHVubmVjZXNzYXJ5IGRlY2ltYWwgcGxhY2VzXG4gICAgaWYgKHNhZmVOdW0gPT09IDApIHJldHVybiBcIjBcIlxuICAgIGlmIChzYWZlTnVtID49IDEpIHJldHVybiBzYWZlTnVtLnRvRml4ZWQoMykucmVwbGFjZSgvXFwuPzArJC8sIFwiXCIpXG4gICAgcmV0dXJuIHNhZmVOdW0udG9GaXhlZCg2KS5yZXBsYWNlKC9cXC4/MCskLywgXCJcIilcbiAgfSxcblxuICBmb3JtYXRUaW1lKHNlY29uZHM6IG51bWJlcik6IHN0cmluZyB7XG4gICAgY29uc3Qgc2FmZVNlY29uZHMgPSB0eXBlb2Ygc2Vjb25kcyA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4oc2Vjb25kcykgPyBNYXRoLmZsb29yKHNlY29uZHMpIDogMFxuICAgIGNvbnN0IGhvdXJzID0gTWF0aC5mbG9vcihzYWZlU2Vjb25kcyAvIDM2MDApXG4gICAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IoKHNhZmVTZWNvbmRzICUgMzYwMCkgLyA2MClcbiAgICBjb25zdCBzZWNzID0gc2FmZVNlY29uZHMgJSA2MFxuXG4gICAgaWYgKGhvdXJzID4gMCkge1xuICAgICAgcmV0dXJuIGAke2hvdXJzLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX06JHttaW51dGVzLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX06JHtzZWNzLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX1gXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgJHttaW51dGVzLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX06JHtzZWNzLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX1gXG4gICAgfVxuICB9LFxuXG4gIGNhbkNsYWltTWluaW5nKHVzZXI6IFVzZXIpOiBib29sZWFuIHtcbiAgICBpZiAoIXVzZXIuaXNNaW5pbmcgfHwgIXVzZXIubWluaW5nU3RhcnRUaW1lKSByZXR1cm4gZmFsc2VcbiAgICBcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gICAgY29uc3QgbWluaW5nRHVyYXRpb24gPSBNYXRoLmZsb29yKChub3cgLSB1c2VyLm1pbmluZ1N0YXJ0VGltZSkgLyAxMDAwKVxuICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RDbGFpbSA9IE1hdGguZmxvb3IoKG5vdyAtICh1c2VyLmxhc3RDbGFpbVRpbWUgfHwgMCkpIC8gMTAwMClcbiAgICBcbiAgICByZXR1cm4gbWluaW5nRHVyYXRpb24gPj0gKHVzZXIubWluQ2xhaW1UaW1lIHx8IEdBTUVfQ09ORklHLk1JTl9DTEFJTV9USU1FKSAmJiBcbiAgICAgICAgICAgdGltZVNpbmNlTGFzdENsYWltID49IEdBTUVfQ09ORklHLk1JTl9DTEFJTV9JTlRFUlZBTFxuICB9LFxuXG4gIGdldE1pbmluZ0R1cmF0aW9uKHVzZXI6IFVzZXIpOiBudW1iZXIge1xuICAgIGlmICghdXNlci5pc01pbmluZyB8fCAhdXNlci5taW5pbmdTdGFydFRpbWUpIHJldHVybiAwXG4gICAgXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIHJldHVybiBNYXRoLmZsb29yKChub3cgLSB1c2VyLm1pbmluZ1N0YXJ0VGltZSkgLyAxMDAwKVxuICB9LFxuXG4gIGNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzKHVzZXI6IFVzZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5nZXRNaW5pbmdEdXJhdGlvbih1c2VyKVxuICAgIGlmIChkdXJhdGlvbiA9PT0gMCkgcmV0dXJuIDBcbiAgICBcbiAgICAvLyBBcHBseSBtaW5pbmcgdGltZSBsaW1pdHNcbiAgICBjb25zdCBsaW1pdGVkRHVyYXRpb24gPSBNYXRoLm1pbihkdXJhdGlvbiwgR0FNRV9DT05GSUcuTUFYX01JTklOR19USU1FKVxuICAgIFxuICAgIGNvbnN0IHsgZWFybmVkIH0gPSB0aGlzLmNhbGN1bGF0ZU1pbmluZ1Jld2FyZHModXNlciwgbGltaXRlZER1cmF0aW9uKVxuICAgIHJldHVybiBlYXJuZWRcbiAgfSxcblxuICBnZXRSZW1haW5pbmdDbGFpbVRpbWUodXNlcjogVXNlcik6IG51bWJlciB7XG4gICAgaWYgKCF1c2VyLmlzTWluaW5nIHx8ICF1c2VyLm1pbmluZ1N0YXJ0VGltZSkgcmV0dXJuIDBcbiAgICBcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gICAgY29uc3QgbWluaW5nRHVyYXRpb24gPSBNYXRoLmZsb29yKChub3cgLSB1c2VyLm1pbmluZ1N0YXJ0VGltZSkgLyAxMDAwKVxuICAgIGNvbnN0IG1pblRpbWUgPSB1c2VyLm1pbkNsYWltVGltZSB8fCBHQU1FX0NPTkZJRy5NSU5fQ0xBSU1fVElNRVxuICAgIFxuICAgIHJldHVybiBNYXRoLm1heCgwLCBtaW5UaW1lIC0gbWluaW5nRHVyYXRpb24pXG4gIH0sXG59Il0sIm5hbWVzIjpbIkdBTUVfQ09ORklHIiwiUkVGRVJSQUxfQk9OVVMiLCJCQVNFX01JTklOR19SQVRFIiwiV0VMQ09NRV9CT05VUyIsIkpBQ0tQT1RfQ09PTERPV04iLCJNSU5fQ0xBSU1fVElNRSIsIk1JTl9DTEFJTV9JTlRFUlZBTCIsIk1BWF9NSU5JTkdfVElNRSIsIkRBSUxZX01JTklOR19SRVdBUkQiLCJDUklUSUNBTF9DSEFOQ0UiLCJKQUNLUE9UX0NIQU5DRSIsIk1BWF9MRVZFTCIsIlhQX1BFUl9MRVZFTCIsIkRSWF9UT19VQ19SQVRFIiwiQkFTRV9YUF9SRVdBUkQiLCJSRUZFUlJBTF9YUF9CT05VUyIsIk1JTklOR19TUEVFRF9NVUxUSVBMSUVSIiwiQ0xBSU1fVElNRV9SRURVQ1RJT04iLCJNSU5JTkdfUkFURV9NVUxUSVBMSUVSIiwiZ2FtZUxvZ2ljIiwiY2FsY3VsYXRlTWluaW5nUmV3YXJkcyIsInVzZXIiLCJtaW5pbmdEdXJhdGlvbiIsImJhc2VSYXRlIiwibWluaW5nUmF0ZSIsImVhcm5lZCIsInR5cGUiLCJ4cCIsIk1hdGgiLCJmbG9vciIsIm1pbmluZ1NwZWVkTXVsdGlwbGllciIsImJvb3N0cyIsIm1pbmluZ1NwZWVkTGV2ZWwiLCJtaW5pbmdSYXRlTXVsdGlwbGllciIsIm1pbmluZ1JhdGVMZXZlbCIsIm1heCIsImNhbGN1bGF0ZUxldmVsIiwibGV2ZWwiLCJyZW1haW5pbmdYUCIsInRvdGFsWFBOZWVkZWQiLCJnZXRYcEZvckxldmVsIiwieHBGb3JUaGlzTGV2ZWwiLCJjdXJyZW50WFAiLCJ4cEZvck5leHQiLCJjYWxjdWxhdGVSYW5rIiwidG90YWxFYXJuZWQiLCJyYW5rcyIsInRocmVzaG9sZCIsInRpdGxlIiwiaWNvbiIsImN1cnJlbnRSYW5rIiwiY3VycmVudFRpdGxlIiwiY3VycmVudEljb24iLCJuZXh0UmFua0F0IiwiaSIsImxlbmd0aCIsInJhbmsiLCJnZXRCb29zdENvc3QiLCJib29zdFR5cGUiLCJjdXJyZW50TGV2ZWwiLCJiYXNlQ29zdHMiLCJtaW5pbmdTcGVlZCIsImNsYWltVGltZSIsImJhc2VDb3N0IiwicG93IiwiZ2V0TmV4dEJvb3N0VmFsdWUiLCJuZXh0U3BlZWRNdWx0aXBsaWVyIiwidG9GaXhlZCIsImN1cnJlbnRUaW1lIiwibWluQ2xhaW1UaW1lIiwibmV4dFRpbWUiLCJmb3JtYXRUaW1lIiwibmV4dFJhdGVNdWx0aXBsaWVyIiwibmV4dFJhdGUiLCJmb3JtYXROdW1iZXJQcmVjaXNlIiwiZm9ybWF0TnVtYmVyIiwibnVtIiwic2FmZU51bSIsImlzTmFOIiwidG9TdHJpbmciLCJyZXBsYWNlIiwic2Vjb25kcyIsInNhZmVTZWNvbmRzIiwiaG91cnMiLCJtaW51dGVzIiwic2VjcyIsInBhZFN0YXJ0IiwiY2FuQ2xhaW1NaW5pbmciLCJpc01pbmluZyIsIm1pbmluZ1N0YXJ0VGltZSIsIm5vdyIsIkRhdGUiLCJ0aW1lU2luY2VMYXN0Q2xhaW0iLCJsYXN0Q2xhaW1UaW1lIiwiZ2V0TWluaW5nRHVyYXRpb24iLCJjYWxjdWxhdGVQZW5kaW5nUmV3YXJkcyIsImR1cmF0aW9uIiwibGltaXRlZER1cmF0aW9uIiwibWluIiwiZ2V0UmVtYWluaW5nQ2xhaW1UaW1lIiwibWluVGltZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/game-logic.ts\n"));

/***/ })

});